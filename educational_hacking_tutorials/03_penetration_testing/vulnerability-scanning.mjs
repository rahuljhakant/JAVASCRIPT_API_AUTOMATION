/**
 * EDUCATIONAL HACKING TUTORIALS
 * Module 3: Penetration Testing
 * Lesson 2: Vulnerability Scanning
 * 
 * ‚ö†Ô∏è IMPORTANT: Educational Purpose Only
 * 
 * Learning Objectives:
 * - Understand vulnerability scanning techniques
 * - Learn to identify common vulnerabilities
 * - Implement safe vulnerability detection
 * - Practice ethical vulnerability assessment
 */

import { expect } from "chai";
import supertest from "supertest";

console.log("=== VULNERABILITY SCANNING ===");

// Vulnerability Scanner
class VulnerabilityScanner {
  constructor() {
    this.vulnerabilities = [];
    this.scanResults = {
      totalScanned: 0,
      vulnerabilitiesFound: 0,
      severity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      }
    };
  }

  async scanEndpoint(url, method = "GET") {
    this.scanResults.totalScanned++;
    
    const vulnerabilities = [];
    
    // Check for common security headers
    const securityHeaders = await this.checkSecurityHeaders(url);
    if (!securityHeaders.hasHTTPS) {
      vulnerabilities.push({
        type: "Missing HTTPS",
        severity: "high",
        description: "Endpoint does not use HTTPS encryption"
      });
    }
    
    if (!securityHeaders.hasCSP) {
      vulnerabilities.push({
        type: "Missing Content Security Policy",
        severity: "medium",
        description: "No CSP header found, vulnerable to XSS attacks"
      });
    }
    
    if (!securityHeaders.hasHSTS) {
      vulnerabilities.push({
        type: "Missing HSTS",
        severity: "medium",
        description: "No HSTS header found"
      });
    }
    
    // Check for information disclosure
    const infoDisclosure = await this.checkInformationDisclosure(url);
    if (infoDisclosure.hasServerInfo) {
      vulnerabilities.push({
        type: "Information Disclosure",
        severity: "low",
        description: `Server information exposed: ${infoDisclosure.serverInfo}`
      });
    }
    
    // Check for insecure methods
    const insecureMethods = await this.checkInsecureMethods(url);
    if (insecureMethods.length > 0) {
      vulnerabilities.push({
        type: "Insecure HTTP Methods",
        severity: "medium",
        description: `Insecure methods allowed: ${insecureMethods.join(", ")}`
      });
    }
    
    this.vulnerabilities.push(...vulnerabilities);
    this.scanResults.vulnerabilitiesFound += vulnerabilities.length;
    
    vulnerabilities.forEach(vuln => {
      this.scanResults.severity[vuln.severity]++;
    });
    
    return vulnerabilities;
  }

  async checkSecurityHeaders(url) {
    try {
      const response = await supertest(url)
        .get("/")
        .timeout(5000);
      
      const headers = response.headers;
      
      return {
        hasHTTPS: url.startsWith("https://"),
        hasCSP: !!headers["content-security-policy"],
        hasHSTS: !!headers["strict-transport-security"],
        hasXFrameOptions: !!headers["x-frame-options"],
        hasXContentTypeOptions: !!headers["x-content-type-options"]
      };
    } catch (error) {
      return {
        hasHTTPS: false,
        hasCSP: false,
        hasHSTS: false,
        hasXFrameOptions: false,
        hasXContentTypeOptions: false
      };
    }
  }

  async checkInformationDisclosure(url) {
    try {
      const response = await supertest(url)
        .get("/")
        .timeout(5000);
      
      const headers = response.headers;
      const serverInfo = headers.server || headers["x-powered-by"] || null;
      
      return {
        hasServerInfo: !!serverInfo,
        serverInfo: serverInfo
      };
    } catch (error) {
      return {
        hasServerInfo: false,
        serverInfo: null
      };
    }
  }

  async checkInsecureMethods(url) {
    const insecureMethods = [];
    const methods = ["OPTIONS", "TRACE", "DELETE", "PUT"];
    
    for (const method of methods) {
      try {
        const response = await supertest(url)
          [method.toLowerCase()]("/")
          .timeout(2000);
        
        if (response.status !== 405 && response.status !== 501) {
          insecureMethods.push(method);
        }
      } catch (error) {
        // Method not allowed or not implemented is expected
      }
    }
    
    return insecureMethods;
  }

  async scanForSQLInjection(url, endpoint) {
    const payloads = [
      "' OR '1'='1",
      "1' UNION SELECT NULL--",
      "admin'--",
      "' OR 1=1--"
    ];
    
    const vulnerabilities = [];
    
    for (const payload of payloads) {
      try {
        const response = await supertest(url)
          .get(`${endpoint}?id=${encodeURIComponent(payload)}`)
          .timeout(5000);
        
        // Check for SQL error patterns
        const body = JSON.stringify(response.body).toLowerCase();
        const sqlErrors = [
          "sql syntax",
          "mysql",
          "postgresql",
          "sqlite",
          "ora-",
          "sql server"
        ];
        
        if (sqlErrors.some(error => body.includes(error))) {
          vulnerabilities.push({
            type: "SQL Injection",
            severity: "critical",
            description: `Potential SQL injection vulnerability detected with payload: ${payload}`,
            payload: payload
          });
        }
      } catch (error) {
        // Continue scanning
      }
    }
    
    return vulnerabilities;
  }

  generateReport() {
    console.log("\nüìä Vulnerability Scan Report:");
    console.log("=" .repeat(50));
    console.log(`Total Endpoints Scanned: ${this.scanResults.totalScanned}`);
    console.log(`Vulnerabilities Found: ${this.scanResults.vulnerabilitiesFound}`);
    console.log("\nSeverity Breakdown:");
    console.log(`  Critical: ${this.scanResults.severity.critical}`);
    console.log(`  High: ${this.scanResults.severity.high}`);
    console.log(`  Medium: ${this.scanResults.severity.medium}`);
    console.log(`  Low: ${this.scanResults.severity.low}`);
    console.log(`  Info: ${this.scanResults.severity.info}`);
    console.log("=" .repeat(50));
    
    return {
      summary: this.scanResults,
      vulnerabilities: this.vulnerabilities
    };
  }
}

// Test Scenarios
async function testSecurityHeaders() {
  console.log("\nüìù Test 1: Security Headers Check");
  
  const scanner = new VulnerabilityScanner();
  const url = "https://example.com";
  
  const headers = await scanner.checkSecurityHeaders(url);
  expect(headers).to.have.property("hasHTTPS");
  expect(headers).to.have.property("hasCSP");
  
  console.log("‚úÖ Security headers check test passed");
}

async function testInformationDisclosure() {
  console.log("\nüìù Test 2: Information Disclosure Check");
  
  const scanner = new VulnerabilityScanner();
  const url = "https://example.com";
  
  const disclosure = await scanner.checkInformationDisclosure(url);
  expect(disclosure).to.have.property("hasServerInfo");
  
  console.log("‚úÖ Information disclosure check test passed");
}

async function testVulnerabilityScanning() {
  console.log("\nüìù Test 3: Vulnerability Scanning");
  
  const scanner = new VulnerabilityScanner();
  const url = "https://example.com";
  
  const vulnerabilities = await scanner.scanEndpoint(url);
  expect(vulnerabilities).to.be.an("array");
  
  console.log(`‚úÖ Found ${vulnerabilities.length} potential vulnerabilities`);
}

async function testVulnerabilityReport() {
  console.log("\nüìù Test 4: Generate Vulnerability Report");
  
  const scanner = new VulnerabilityScanner();
  await scanner.scanEndpoint("https://example.com");
  
  const report = scanner.generateReport();
  expect(report).to.have.property("summary");
  expect(report).to.have.property("vulnerabilities");
  
  console.log("‚úÖ Vulnerability report generation test passed");
}

// Run all tests
(async () => {
  try {
    console.log("\n‚ö†Ô∏è  REMINDER: This tutorial is for educational purposes only.");
    console.log("   Only scan systems you own or have explicit permission to scan.\n");
    
    await testSecurityHeaders();
    await testInformationDisclosure();
    await testVulnerabilityScanning();
    await testVulnerabilityReport();
    
    console.log("\n‚úÖ All vulnerability scanning tests completed!");
    console.log("\nüìö Key Takeaways:");
    console.log("   - Always obtain authorization before scanning");
    console.log("   - Document all findings for responsible disclosure");
    console.log("   - Prioritize vulnerabilities by severity");
    console.log("   - Follow responsible disclosure practices");
  } catch (error) {
    console.error("‚ùå Test failed:", error.message);
    process.exit(1);
  }
})();

